
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Build your own Blockchain (GoLang Programming)</title>
  <script src="bower_components/webcomponentsjs/webcomponents-lite.js"></script>
  <link rel="import" href="elements/codelab.html">
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <style is="custom-style">
    body {
      font-family: "Roboto",sans-serif;
      background: var(--google-codelab-background, #F8F9FA);
    }
  </style>
  
</head>
<body unresolved class="fullbleed">

  <google-codelab title="Build your own Blockchain (GoLang Programming)"
                  environment="web"
                  feedback-link="github.com/kenken64">
    
      <google-codelab-step label="Overview of the workshop" duration="16">
        <p>This workshop shows you how to create your own simple blockchain. In this tutorial you will be doing the following:-</p>
<ul>
<li>Understand various component of simple blockchain</li>
<li>Link up all the components of the blockchain</li>
<li>Define data structure of the blockchain</li>
<li>Implement blockchain REST API end point for integration</li>
<li>Allow multiple blockchain nodes connect to the master node for block synchronization</li>
</ul>
<h2>Pre-requisite</h2>
<ul>
<li><a href="https://golang.org/dl/" target="_blank">Go Language</a></li>
<li><a href="https://nodejs.org/en/download/" target="_blank">Node JS</a></li>
<li><a href="https://code.visualstudio.com/download" target="_blank">Microsoft Visual Studio Code</a> / <a href="https://atom.io/" target="_blank">Atom</a> / <a href="https://www.jetbrains.com/go/download/#section=windows" target="_blank">GoLand</a></li>
<li>Operating system: Linux/Windows/MacOS</li>
</ul>
<h2>Missing feature</h2>
<ul>
<li>Wallet synchronization</li>
<li>Sign transaction</li>
<li>Verify transaction</li>
<li>Transaction synchronization across nodes</li>
<li>Transaction Pool</li>
<li>Difficulty adjustment for mining (transaction verification)</li>
<li>Consensus Algorithm - criteria to place the transaction into the digital ledger</li>
<li>A smart contract virtual machine</li>
<li>An implementation where the Miner&#39;s mine() function only grabs a group of the transactions, and not the entire pool. When the subset of transactions from the pool is included in the chain, they would need to be cleared from the pool, and synchronized across all miners.</li>
<li>Route the blockchain-approved reward transactions through its own dedicated server. That way, not everyone can create transactions through the special blockchain wallet.</li>
<li>Transaction fee for mining process.</li>
<li>Handle 51% attack to prevent double spending</li>
</ul>
<p>For all this missing feature please refer to the Javascript <a href="https://github.com/kenken64/MerlionCoin" target="_blank">version</a></p>
<aside class="warning"><p>Please do not proceed without having all the pre-requisite and dependendies installed.<br></p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Getting setup" duration="36">
        <h2>Install Node JS</h2>
<ul>
<li>Download Node JS from the following <a href="https://nodejs.org/en/download/" target="_blank">hyperlink</a> , select the correct platform based on your machine&#39;s operating system</li>
<li>Install Node JS binaries</li>
</ul>
<h2>Install GoLang</h2>
<ul>
<li>Download Golang from the following <a href="https://golang.org/dl/" target="_blank">hyperlink</a> , select the correct platform based on your machine&#39;s operating system</li>
<li>Install Go Language binaries</li>
</ul>
<h2>Install Gomon  (Source code watcher)</h2>
<ul>
<li>Download Gomon npm libraries from the following <a href="https://github.com/johannesboyne/gomon" target="_blank">hyperlink</a> , select the correct platform based on your machine&#39;s operating system</li>
<li>Install Gomon Node JS library</li>
</ul>
<pre><code>npm install -g go-mon
</code></pre>
<h2>GoLang Dependencies</h2>
<h2>Get GoLang Web middleware - GIN</h2>
<ul>
<li>Install GIN library to your project home directory, further feature please refer to GIN documentation (https://github.com/gin-gonic/gin)</li>
</ul>
<pre><code>go get github.com/gin-gonic/gin
</code></pre>
<h2>Get GoLang Websocket - GORILLA</h2>
<ul>
<li>Install GORILLA libary to your project home directory, further feature please refer to GORILLA documentation (http://www.gorillatoolkit.org/pkg/websocket)</li>
</ul>
<pre><code>go get github.com/gorilla/websocket
</code></pre>
<h2>Get ripeMD160</h2>
<ul>
<li>Install package ripemd160 implements the RIPEMD-160 hash algorithm.</li>
</ul>
<pre><code>go get golang.org/x/crypto/ripemd160
</code></pre>
<h2>Get fast key value database (BoltDB)</h2>
<ul>
<li>Install bolt package for fast key value database</li>
</ul>
<pre><code>go get github.com/boltdb/bolt
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Go Programming Language" duration="30">
        <h2>Features</h2>
<p>The key features are the form of learning Go. All the tasks are challenging, and most come from the real open libraries as well as relevant papers or talks, however not difficult to complete. It will help you understand main parts of these works instead of browsing the huge code.</p>
<p>In my opinion the best way to learn coding is just coding.</p>
<p>There are currently 10 exercises, those works were done during the weekend of hackthon, so they are not seemingly that perfect, but I am sure, you will gain a lot if you finish the tasks.</p>
<h2>How to install</h2>
<p>This repo has no dependencies, so you can install by typing:</p>
<pre><code>git clone https://github.com/gophergala/learn-Go-the-hard-way
</code></pre>
<p>or</p>
<pre><code>go get -u github.com/gophergala/learn-Go-the-hard-way
</code></pre>
<h2>How to use</h2>
<p>You should complete the current exercise before you enter the next.</p>
<p>Each exercise is a git tag (from l1 to l10), you can check out the tag, and finish the task with tips.</p>
<p>Run go test, if you complete the task, and it will tell you whether you pass the task.</p>
<p>To get the tips, please run go run main.go, and follow the tips to modify main.go.</p>
<h2>Printing</h2>
<p>Formatted printing in Go uses a style similar to C&#39;s printf family but is richer and more general. The functions live in the fmt package and have capitalized names: fmt.Printf, fmt.Fprintf, fmt.Sprintf and so on. The string functions (Sprintf etc.) return a string rather than filling in a provided buffer.</p>
<p>You don&#39;t need to provide a format string. For each of Printf, Fprintf and Sprintf there is another pair of functions, for instance Print and Println. These functions do not take a format string but instead generate a default format for each argument. The Println versions also insert a blank between arguments and append a newline to the output while the Print versions add blanks only if the operand on neither side is a string. In this example each line produces the same output.</p>
<pre><code>fmt.Printf(&#34;Hello %d\n&#34;, 23)
fmt.Fprint(os.Stdout, &#34;Hello &#34;, 23, &#34;\n&#34;)
fmt.Println(&#34;Hello&#34;, 23)
fmt.Println(fmt.Sprint(&#34;Hello &#34;, 23))
</code></pre>
<pre><code>var x uint64 = 1&lt;&lt;64 - 1
fmt.Printf(&#34;%d %x; %d %x\n&#34;, x, x, int64(x), int64(x))
</code></pre>
<pre><code>var x uint64 = 1&lt;&lt;64 - 1
fmt.Printf(&#34;%d %x; %d %x\n&#34;, x, x, int64(x), int64(x))
</code></pre>
<pre><code>type T struct {
    a int
    b float64
    c string
}
t := &amp;T{ 7, -2.35, &#34;abc\tdef&#34; }
fmt.Printf(&#34;%v\n&#34;, t)
fmt.Printf(&#34;%+v\n&#34;, t)
fmt.Printf(&#34;%#v\n&#34;, t)
fmt.Printf(&#34;%#v\n&#34;, timeZone)
</code></pre>
<h2>Append</h2>
<p>Now we have the missing piece we needed to explain the design of the append built-in function. The signature of append is different from our custom Append function above. Schematically, it&#39;s like this:</p>
<pre><code>x := []int{1,2,3}
x = append(x, 4, 5, 6)
fmt.Println(x)
</code></pre>
<h2>Constant</h2>
<p>Constants in Go are just that—constant. They are created at compile time, even when defined as locals in functions, and can only be numbers, characters (runes), strings or booleans.</p>
<pre><code>type ByteSize float64

const (
    _           = iota // ignore first value by assigning to blank identifier
    KB ByteSize = 1 &lt;&lt; (10 * iota)
    MB
    GB
    TB
    PB
    EB
    ZB
    YB
)
</code></pre>
<h2>Commentary</h2>
<pre><code>/*
Package regexp implements a simple library for regular expressions.

The syntax of the regular expressions accepted is:

    regexp:
        concatenation { &#39;|&#39; concatenation }
    concatenation:
        { closure }
    closure:
        term [ &#39;*&#39; | &#39;+&#39; | &#39;?&#39; ]
    term:
        &#39;^&#39;
        &#39;$&#39;
        &#39;.&#39;
        character
        &#39;[&#39; [ &#39;^&#39; ] character-ranges &#39;]&#39;
        &#39;(&#39; regexp &#39;)&#39;
*/
package regexp
</code></pre>
<p>If every doc comment begins with the name of the item it describes, you can use the doc subcommand of the go tool and run the output through grep. Imagine you couldn&#39;t remember the name &#34;Compile&#34; but were looking for the parsing function for regular expressions, so you ran the command,</p>
<pre><code>go doc -all regexp | grep -i parse
</code></pre>
<h2>Package names</h2>
<p>When a package is imported, the package name becomes an accessor for the contents. After</p>
<pre><code>import &#34;bytes&#34;
</code></pre>
<p>he importing package can talk about bytes.Buffer. It&#39;s helpful if everyone using the package can use the same name to refer to its contents, which implies that the package name should be good: short, concise, evocative. By convention, packages are given lower case, single-word names; there should be no need for underscores or mixedCaps. Err on the side of brevity, since everyone using your package will be typing that name. And don&#39;t worry about collisions a priori. The package name is only the default name for imports; it need not be unique across all source code, and in the rare case of a collision the importing package can choose a different name to use locally. In any case, confusion is rare because the file name in the import determines just which package is being used.</p>
<h2>Semicolons</h2>
<p>Like C, Go&#39;s formal grammar uses semicolons to terminate statements, but unlike in C, those semicolons do not appear in the source. Instead the lexer uses a simple rule to insert semicolons automatically as it scans, so the input text is mostly free of them.</p>
<p>The rule is this. If the last token before a newline is an identifier (which includes words like int and float64), a basic literal such as a number or string constant, or one of the tokens</p>
<pre><code>break continue fallthrough return ++ -- ) }
</code></pre>
<h2>Control Statements - If</h2>
<p>The control structures of Go are related to those of C but differ in important ways. There is no do or while loop, only a slightly generalized for; switch is more flexible; if and switch accept an optional initialization statement like that of for; break and continue statements take an optional label to identify what to break or continue; and there are new control structures including a type switch and a multiway communications multiplexer, select. The syntax is also slightly different: there are no parentheses and the bodies must always be brace-delimited.</p>
<pre><code>if x &gt; 0 {
    return y
}
</code></pre>
<pre><code>f, err := os.Open(name)
if err != nil {
    return err
}
d, err := f.Stat()
if err != nil {
    f.Close()
    return err
}
codeUsing(f, d)
</code></pre>
<h2>Redeclaration and reassignment</h2>
<p>An aside: The last example in the previous section demonstrates a detail of how the := short declaration form works. The declaration that calls os.Open reads,</p>
<pre><code>f, err := os.Open(name)
</code></pre>
<p>This statement declares two variables, f and err. A few lines later, the call to f.Stat reads,</p>
<pre><code>d, err := f.Stat()
</code></pre>
<h2>Control Statements - For</h2>
<p>The Go for loop is similar to—but not the same as—C&#39;s. It unifies for and while and there is no do-while. There are three forms, only one of which has semicolons.</p>
<pre><code>// Like a C for
for init; condition; post { }

// Like a C while
for condition { }

// Like a C for(;;)
for { }
</code></pre>
<p>Short declarations make it easy to declare the index variable right in the loop.</p>
<pre><code>sum := 0
for i := 0; i &lt; 10; i++ {
    sum += i
}
</code></pre>
<pre><code>for key, value := range oldMap {
    newMap[key] = value
}
</code></pre>
<pre><code>for key := range m {
    if key.expired() {
        delete(m, key)
    }
}
</code></pre>
<pre><code>sum := 0
for _, value := range array {
    sum += value
}
</code></pre>
<h2>Switch</h2>
<p>Go&#39;s switch is more general than C&#39;s. The expressions need not be constants or even integers, the cases are evaluated top to bottom until a match is found, and if the switch has no expression it switches on true. It&#39;s therefore possible—and idiomatic—to write an if-else-if-else chain as a switch.</p>
<pre><code>func unhex(c byte) byte {
    switch {
    case &#39;0&#39; &lt;= c &amp;&amp; c &lt;= &#39;9&#39;:
        return c - &#39;0&#39;
    case &#39;a&#39; &lt;= c &amp;&amp; c &lt;= &#39;f&#39;:
        return c - &#39;a&#39; + 10
    case &#39;A&#39; &lt;= c &amp;&amp; c &lt;= &#39;F&#39;:
        return c - &#39;A&#39; + 10
    }
    return 0
}
</code></pre>
<h2>Type switch</h2>
<p>A switch can also be used to discover the dynamic type of an interface variable. Such a type switch uses the syntax of a type assertion with the keyword type inside the parentheses.</p>
<pre><code>var t interface{}
t = functionOfSomeType()
switch t := t.(type) {
default:
    fmt.Printf(&#34;unexpected type %T\n&#34;, t)     // %T prints whatever type t has
case bool:
    fmt.Printf(&#34;boolean %t\n&#34;, t)             // t has type bool
case int:
    fmt.Printf(&#34;integer %d\n&#34;, t)             // t has type int
case *bool:
    fmt.Printf(&#34;pointer to boolean %t\n&#34;, *t) // t has type *bool
case *int:
    fmt.Printf(&#34;pointer to integer %d\n&#34;, *t) // t has type *int
}
</code></pre>
<h2>Array</h2>
<p>Arrays are useful when planning the detailed layout of memory and sometimes can help avoid allocation, but primarily they are a building block for slices, the subject of the next section. To lay the foundation for that topic, here are a few words about arrays.</p>
<pre><code>func Sum(a *[3]float64) (sum float64) {
    for _, v := range *a {
        sum += v
    }
    return
}

array := [...]float64{7.0, 8.5, 9.1}
x := Sum(&amp;array)  // Note the explicit address-of operator
</code></pre>
<h2>Slices</h2>
<p>Slices wrap arrays to give a more general, powerful, and convenient interface to sequences of data. Except for items with explicit dimension such as transformation matrices, most array programming in Go is done with slices rather than simple arrays.</p>
<pre><code>var n int
    var err error
    for i := 0; i &lt; 32; i++ {
        nbytes, e := f.Read(buf[i:i+1])  // Read one byte.
        n += nbytes
        if nbytes == 0 || e != nil {
            err = e
            break
        }
    }
</code></pre>
<h2>Two-dimensional slices</h2>
<p>Go&#39;s arrays and slices are one-dimensional. To create the equivalent of a 2D array or slice, it is necessary to define an array-of-arrays or slice-of-slices, like this:</p>
<pre><code>type Transform [3][3]float64  // A 3x3 array, really an array of arrays.
type LinesOfText [][]byte     // A slice of byte slices.

text := LinesOfText{
    []byte(&#34;Now is the time&#34;),
    []byte(&#34;for all good gophers&#34;),
    []byte(&#34;to bring some fun to the party.&#34;),
}
</code></pre>
<h2>Maps</h2>
<p>Maps are a convenient and powerful built-in data structure that associate values of one type (the key) with values of another type (the element or value).</p>
<pre><code>var timeZone = map[string]int{
    &#34;UTC&#34;:  0*60*60,
    &#34;EST&#34;: -5*60*60,
    &#34;CST&#34;: -6*60*60,
    &#34;MST&#34;: -7*60*60,
    &#34;PST&#34;: -8*60*60,
}

offset := timeZone[&#34;EST&#34;]

delete(timeZone, &#34;PST&#34;)  // Now on Standard Time
</code></pre>
<h2>Functions</h2>
<h3>Multiple return values</h3>
<p>One of Go&#39;s unusual features is that functions and methods can return multiple values. This form can be used to improve on a couple of clumsy idioms in C programs: in-band error returns such as -1 for EOF and modifying an argument passed by address.</p>
<pre><code>func nextInt(b []byte, i int) (int, int) {
    for ; i &lt; len(b) &amp;&amp; !isDigit(b[i]); i++ {
    }
    x := 0
    for ; i &lt; len(b) &amp;&amp; isDigit(b[i]); i++ {
        x = x*10 + int(b[i]) - &#39;0&#39;
    }
    return x, i
}

</code></pre>
<h3>Named result parameters</h3>
<p>The return or result &#34;parameters&#34; of a Go function can be given names and used as regular variables, just like the incoming parameters.</p>
<pre><code>func ReadFull(r Reader, buf []byte) (n int, err error) {
    for len(buf) &gt; 0 &amp;&amp; err == nil {
        var nr int
        nr, err = r.Read(buf)
        n += nr
        buf = buf[nr:]
    }
    return
}
</code></pre>
<h3>Defer</h3>
<p>Go&#39;s defer statement schedules a function call (the deferred function) to be run immediately before the function executing the defer returns.</p>
<pre><code>// Contents returns the file&#39;s contents as a string.
func Contents(filename string) (string, error) {
    f, err := os.Open(filename)
    if err != nil {
        return &#34;&#34;, err
    }
    defer f.Close()  // f.Close will run when we&#39;re finished.

    var result []byte
    buf := make([]byte, 100)
    for {
        n, err := f.Read(buf[0:])
        result = append(result, buf[0:n]...) // append is discussed later.
        if err != nil {
            if err == io.EOF {
                break
            }
            return &#34;&#34;, err  // f will be closed if we return here.
        }
    }
    return string(result), nil // f will be closed if we return here.
}
</code></pre>
<pre><code>for i := 0; i &lt; 5; i++ {
    defer fmt.Printf(&#34;%d &#34;, i)
}
</code></pre>
<h2>Data</h2>
<h3>Allocation with new</h3>
<p>o has two allocation primitives, the built-in functions new and make. They do different things and apply to different types, which can be confusing, but the rules are simple.</p>
<pre><code>type SyncedBuffer struct {
    lock    sync.Mutex
    buffer  bytes.Buffer
}

p := new(SyncedBuffer)  // type *SyncedBuffer
var v SyncedBuffer      // type  SyncedBuffer
</code></pre>
<h3>Constructors and composite literals</h3>
<p>Sometimes the zero value isn&#39;t good enough and an initializing constructor is necessary, as in this example derived from package os.</p>
<pre><code>func NewFile(fd int, name string) *File {
    if fd &lt; 0 {
        return nil
    }
    f := new(File)
    f.fd = fd
    f.name = name
    f.dirinfo = nil
    f.nepipe = 0
    return f
}
</code></pre>
<pre><code>return &amp;File{fd, name, nil, 0}
</code></pre>
<h2>Interfaces</h2>
<p>Interfaces in Go provide a way to specify the behavior of an object: if something can do this, then it can be used here.</p>
<pre><code>type Sequence []int

// Methods required by sort.Interface.
func (s Sequence) Len() int {
    return len(s)
}
func (s Sequence) Less(i, j int) bool {
    return s[i] &lt; s[j]
}
func (s Sequence) Swap(i, j int) {
    s[i], s[j] = s[j], s[i]
}

// Copy returns a copy of the Sequence.
func (s Sequence) Copy() Sequence {
    copy := make(Sequence, 0, len(s))
    return append(copy, s...)
}

// Method for printing - sorts the elements before printing.
func (s Sequence) String() string {
    s = s.Copy() // Make a copy; don&#39;t overwrite argument.
    sort.Sort(s)
    str := &#34;[&#34;
    for i, elem := range s { // Loop is O(N²); will fix that in next example.
        if i &gt; 0 {
            str += &#34; &#34;
        }
        str += fmt.Sprint(elem)
    }
    return str + &#34;]&#34;
}
</code></pre>
<h2>Import for side effect</h2>
<p>An unused import like fmt or io in the previous example should eventually be used or removed: blank assignments identify code as a work in progress.</p>
<pre><code>import _ &#34;net/http/pprof&#34;
</code></pre>
<h2>Concurrency</h2>
<h3>Goroutines</h3>
<p>They&#39;re called goroutines because the existing terms—threads, coroutines, processes, and so on—convey inaccurate connotations. A goroutine has a simple model: it is a function executing concurrently with other goroutines in the same address space. It is lightweight, costing little more than the allocation of stack space. And the stacks start small, so they are cheap, and grow by allocating (and freeing) heap storage as required.</p>
<pre><code>go list.Sort()  // run list.Sort concurrently; don&#39;t wait for it.
</code></pre>
<pre><code>func Announce(message string, delay time.Duration) {
    go func() {
        time.Sleep(delay)
        fmt.Println(message)
    }()  // Note the parentheses - must call the function.
}
</code></pre>
<h3>Channel</h3>
<p>Like maps, channels are allocated with make, and the resulting value acts as a reference to an underlying data structure. If an optional integer parameter is provided, it sets the buffer size for the channel. The default is zero, for an unbuffered or synchronous channel.</p>
<pre><code>c := make(chan int)  // Allocate a channel.
// Start the sort in a goroutine; when it completes, signal on the channel.
go func() {
    list.Sort()
    c &lt;- 1  // Send a signal; value does not matter.
}()
doSomethingForAWhile()
&lt;-c   // Wait for sort to finish; discard sent value.
</code></pre>
<h3>Channels of channels</h3>
<p>One of the most important properties of Go is that a channel is a first-class value that can be allocated and passed around like any other. A common use of this property is to implement safe, parallel demultiplexing.</p>
<pre><code>type Request struct {
    args        []int
    f           func([]int) int
    resultChan  chan int
}
</code></pre>
<pre><code>func sum(a []int) (s int) {
    for _, v := range a {
        s += v
    }
    return
}

request := &amp;Request{[]int{3, 4, 5}, sum, make(chan int)}
// Send request
clientRequests &lt;- request
// Wait for response.
fmt.Printf(&#34;answer: %d\n&#34;, &lt;-request.resultChan)
</code></pre>
<h3>Parallelization</h3>
<p>Another application of these ideas is to parallelize a calculation across multiple CPU cores. If the calculation can be broken into separate pieces that can execute independently, it can be parallelized, with a channel to signal when each piece completes.</p>
<pre><code>var numCPU = runtime.NumCPU()

func (v Vector) DoAll(u Vector) {
    c := make(chan int, numCPU)  // Buffering optional but sensible.
    for i := 0; i &lt; numCPU; i++ {
        go v.DoSome(i*len(v)/numCPU, (i+1)*len(v)/numCPU, u, c)
    }
    // Drain the channel.
    for i := 0; i &lt; numCPU; i++ {
        &lt;-c    // wait for one task to complete
    }
    // All done.
}
</code></pre>
<h2>Panic</h2>
<p>The usual way to report an error to a caller is to return an error as an extra return value. The canonical Read method is a well-known instance; it returns a byte count and an error.</p>
<pre><code>var user = os.Getenv(&#34;USER&#34;)

func init() {
    if user == &#34;&#34; {
        panic(&#34;no value for $USER&#34;)
    }
}

</code></pre>
<h2>Recover</h2>
<p>When panic is called, including implicitly for run-time errors such as indexing a slice out of bounds or failing a type assertion, it immediately stops execution of the current function and begins unwinding the stack of the goroutine, running any deferred functions along the way. If that unwinding reaches the top of the goroutine&#39;s stack, the program dies.</p>
<pre><code>func server(workChan &lt;-chan *Work) {
    for work := range workChan {
        go safelyDo(work)
    }
}

func safelyDo(work *Work) {
    defer func() {
        if err := recover(); err != nil {
            log.Println(&#34;work failed:&#34;, err)
        }
    }()
    do(work)
}
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="What the facts (WTF)" duration="21">
        <h2>What is Blockchain?</h2>
<p>a digital ledger in which transactions are recorded chronologically and publicly. A public permanent append-only distributed ledger</p>
<p>For a cryptocurrency application, the ledger stores all transactions such as who transferred funds to who, similar to a bank ledger. Each set of transactions is represented as a block on the blockchain. A block can store multiple transactions.<br><a href="https://www.youtube.com/watch?v=SSo_EIwHSd4&t=76s" target="_blank"><br>View Video</a></p>
<p>Once a transaction has been committed (mined) to the blockchain (ledger), it can&#39;t be edited or removed. Also, all nodes on the blockchain network keep a replicated copy of the blockchain so there is no central place where the block chain is stored. When a new block is added to the blockchain, all nodes in the blockchain network are updated to have the newest version of the blockchain.</p>
<p>Every block in the chain is linked to the previous block by storing the hash value of the previous block, which creates a chain of blocks.</p>
<p>Instead of a central trusted authority like a bank, the blockchain network itself acts as the trusted authority because of its built in trust and security features. This eliminates the need for middle men such as banks and doesn&#39;t have a single point of failure. An attacker would have to take over a large segment of a blockchain network in order to compromise it whereas a bank robber only needs to rob a single bank to steal a lot of money.</p>
<h2>Features</h2>
<p>This cryptocurrency blockchain has many standard features of popular blockchains like Bitcoin ,Corda, HyperLedger and Ethereum. Many of these features are taken from the original <a href="https://bitcoin.org/bitcoin.pdf" target="_blank">Bitcoin whitepaper</a>:</p>
<ul>
<li>Peer to peer secure blockchain server that accepts multiple connections through a published REST API</li>
<li>Autonomous blockchain network with clients that can engage and disengage from the blockchain full blockchain replication among all the clients</li>
<li>Timestamp on each block so they can be properly ordered</li>
<li>Mining with a proof of work system for adding new blocks to the blockchain with a dynamic difficulty level and a financial incentive</li>
<li>Transaction system for transferring funds between nodes secure wallets for storing a public-private key pair digital signatures (SHA-256) and payment verification</li>
<li>Full suite of unit tests for every aspect of the system</li>
</ul>
<h2>Public and Private Key infrastructure</h2>
<p>In blockchain public is the account address. Private key is used to transfer fund in other words is used to sign and verify the transaction. Private key is very important in blockchain it controls the funds.</p>
<h2>Keeping your private keys secure</h2>
<ul>
<li>Paper wallet</li>
<li>Backup</li>
<li>Hardware (Mcafee hardware wallet got hacked recently)</li>
<li>Online wallet (Hosting app run away with all the consumer&#39;s wallet)</li>
</ul>
<h2>Proof of Work – Blockchain Mining</h2>
<p>A blockchain&#39;s uses proof-of-work as a way to ensure only valid blocks are added to a blockchain and to prevent dishonest nodes from adding blocks. Due to the decentralized nature of a blockchain, any node has a copy of the entire blockchain and can theoretically, add another block. Using proof-of-work makes it computationally expensive to add corrupt blocks.</p>
<p><a href="https://www.youtube.com/watch?v=LgOo3nXsENQ" target="_blank">Youtube Video</a></p>
<h2>Difficulty Level</h2>
<p>There are different proof-of-work systems, but our blockchain uses a similar proof-of-work system that Bitcoin uses, Hashcash. The goal is to generate a hash with a certain number of leading zeros, which is the difficulty level.</p>
<p>For example, if the difficulty level is three, then the miner needs to generate a hash with three leading zeros before being allowed to add a new block to the chain. The higher the difficulty level, the longer it will take to generate a hash that meets that criteria.</p>
<h2>Nonce</h2>
<p>The nonce value is iterated by one on every hash generation attempt. If the hash value satisfies the difficulty level, we save the nonce value in the block so other nodes can quickly validate the hash.</p>
<h2>51% Attack</h2>
<p><img src="img/4136636c159a1357.png"><br><br>A 51% attack could result if a dishonest party could control more than 50% of the computer nodes on the network resulting in the ability to compute hashes faster than any other nodes on the network. This could result in corruption of the blockchain and double spending. The more nodes there are on the network, the less likely this is to happen.</p>
<p><img src="img/3141e8c4a1c66723.png"><br><img src="img/be282482053c90df.png"><br><img src="img/776c5c6cbb9fed93.png"><br><img src="img/4f2dd5aa471fa863.png"><br><img src="img/d5a81127d20b3093.png"><br><a href="https://www.youtube.com/watch?v=3TQ9Sfh-7kQ" target="_blank">Youtube Video</a></p>
<h2>Dynamic Difficulty Level</h2>
<p>The blockchain uses a dynamic difficulty level by increasing the difficulty level if blocks are mined too quickly and decreasing the difficulty level if blocks are mined too slowly. The blockchain&#39;s default mine rate is 3000 milliseconds and the difficulty level is adjusted based on whether blocks are mined faster or slower than this value.</p>
<p>Our blockchain supports the idea of a dynamic difficulty level that changes over time, depending on how quickly blocks are added to the blockchain. Each block stores the difficulty level and the mine rate, which represents the rate at which blocks should be mined. Difficulty level will be adjusted by checking the difference between the current and previous blocks and increasing the difficulty level if the difference is below the target mine rate (to increase mining time) and decreasing the difficulty level if the difference is above the target mine rate (to decrease mining time).</p>
<p><img src="img/be7fe5bbddf898.png"><br></p>
<p><a href="https://etherscan.io/chart/difficulty" target="_blank">Ethereum Block Difficulty Chart</a></p>


      </google-codelab-step>
    
      <google-codelab-step label="Brief walkthrough on Go Programming Language" duration="90">
        <p>Using Tour of Go to run through some of the important concepts in <a href="https://tour.golang.org/" target="_blank">Golang</a></p>
<ul>
<li>Packages</li>
<li>Imports</li>
<li>function</li>
<li>main func</li>
<li>Short var declaration</li>
<li>Type inference</li>
<li>Type conversions</li>
<li>Struct and slices</li>
<li>Errors &amp; Panic</li>
<li>Interfaces</li>
<li>Pointers and function</li>
<li>Go routine (Concurrency)</li>
</ul>
<h2>Golang Notes</h2>
<ul>
<li>Interfaces in Go are very different from, say, Java interfaces. You don&#39;t explicitly say a data type implements an interface; rather, your data types must implement all of the methods that the interface defines, and the compiler checks to see if assignments to variables of the interface type are valid.</li>
</ul>
<pre><code>type Animal interface {
 Name() string
 Bark()
}
</code></pre>
<pre><code>type Dog struct {}

func (d *Dog) Name() string {
 return &#34;Dog&#34;
}
func (d *Dog) Bark() {
 fmt.Println(&#34;Woof!&#34;)
}
</code></pre>
<pre><code>func main() {
 var animal Animal
 animal = &amp;Dog{} // returns a pointer to a new Dog
 fmt.Println(animal.Name()) // Dog
}
</code></pre>
<ul>
<li>Only = is the assignment operator.</li>
<li>short variable declaration := , It is shorthand for a regular variable declaration with initializer expressions but no types:</li>
<li>structs are passed into functions by value. That is, a copy of a structure is made when passing it into a function.</li>
<li>if I want to pass a structure by reference, then I would instead use a pointer argument in the function definition, and use the addressof operator when calling the function.</li>
<li>The reason why I would want to pass in a structure by reference is because either the structure I&#39;m passing in is large, and it would be taxing on memory to pass it by value (unlikely) or if I want to make changes to the copy that I&#39;m passing in (more likely).</li>
<li>As a corollary to 3.), I should pass by value unless I have one of the reasons above to pass by reference.</li>
<li>Appending to a slice<br>⋅⋅⋅ func append(s []T, vs ...T) []T</li>
<li>Go has pointers. A pointer holds the memory address of a value.</li>
</ul>
<p>The type *T is a pointer to a T value. Its zero value is nil.</p>
<pre><code>var p *int
</code></pre>
<p>The &amp; operator generates a pointer to its operand.</p>
<pre><code>i := 42
p = &amp;i
</code></pre>
<p>The * operator denotes the pointer&#39;s underlying value.</p>
<pre><code>fmt.Println(*p) // read i through the pointer p
*p = 21         // set i through the pointer p
</code></pre>
<p>This is known as &#34;dereferencing&#34; or &#34;indirecting&#34;.</p>
<p>Unlike C, Go has no pointer arithmetic.</p>
<ul>
<li>sprintf is string formatting</li>
<li>Format use for time.Time parsing RFC3339     = &#34;2006-01-02T15:04:05Z07:00&#34;</li>
<li>For each read we pick a key to access, Lock() the mutex to ensure exclusive access to the state, read the value at the chosen key, Unlock() the mutex, and increment the readOps count.<br>Wait a bit between reads.</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Block" duration="16">
        <p>The fundamental object of the blockchain is the block, which represents an individual link in the blockchain. The blockchain stores the following properties:</p>
<ul>
<li>current hash (based on the timestamp, hash of previous block and transactions)</li>
<li>hash of the previous block</li>
<li>timestamp</li>
<li>data to store (cryptocurrency transactions but can store generic data, as well)</li>
<li>nonce value (for mining new blocks)</li>
<li>difficulty value (for mining new blocks)</li>
</ul>
<h2>Genesis Block</h2>
<p>The Genesis Block is the very first block in a blockchain – a way to start a blockchain. Since there&#39;s no preceding block, the genesis block uses hard coded dummy values for its previous hash value. This way, when the second block gets added to the blockchain, it will set the value of its previous hash to the hash of the genesis block. Since the genesis block is hard coded, we make it a static method of the Block class, so it&#39;s accessible without instantiating a Block object.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Blockchain" duration="16">
        <p>The Blockchain class is responsible for</p>
<ul>
<li>storing the list of blocks on the blockchain</li>
<li>adding new blocks to the chain</li>
<li>validating new blockschains</li>
<li>replacing current blockchain with a new one (when synchronizing with other nodes).</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Blockchain replication" duration="20">
        <p>What is a forks?</p>
<p>Every node on the network needs to have the same copy of the blockchain. So what happens when a new block gets mined on one node? Now the system has to replicate the new block to all the other nodes on the network so every node is in sync and has the same copy of the blockchain.</p>
<p><img src="img/b2388a31bbd6f95.png"></p>
<p>Since the blockchain needs to be replicated among all nodes in the network, the question arises – what happens if two nodes mine a block at the same time? This is when there&#39;s a fork in the blockchain and the system needs to reconcile the fork and merge all the new blocks.</p>
<p><img src="img/21f24bfed0b8a1b6.png"></p>
<p>When a fork occurs, some nodes will get replicated from node A and some will get replicated from node B which will create the following scenario:</p>
<p><img src="img/f2f6c82fe9421966.png"></p>
<p>We will use the rule that the longest chain will be accepted as the main chain. If there is a conflict between multiple nodes mining blocks at the same time, eventually, one chain will be longer and that will be accepted as the master blockchain. The other blocks that were mined on the shorter chain will be incorporated into the main blockchain.</p>
<p><img src="img/2c6071477a35a6cc.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Blockchain Rest API/Websocket" duration="15">
        <p>The web application expose a series of JSON endpoints that will allow each node on the network to interact with the blockchain with its own HTTP server.</p>
<h2>List of RPC API</h2>
<ul>
<li><a href="https://github.com/ethereum/web3.js/" target="_blank">Ethereum Web3</a></li>
<li><a href="https://cardanodocs.com/technical/wallet/api/v1/" target="_blank">Cardano ADA RPC</a></li>
<li><a href="https://cardanodocs.com/technical/wallet/api/v1/" target="_blank">Stellar RPC</a></li>
</ul>
<h2>JSON-RPC</h2>
<p>JSON-RPC is a type of RPC protocol which uses JSON to encode requests and responses between client and server. The JSON-RPC v2.0 specification was released in 2010 and aims to provide a simple RPC mechanism.</p>
<p>POST /transact – add cryptocurrency transaction to the transaction pool<br>The code for the web application is in src/app/index.ts:</p>
<h2>Peer-to-Peer Server</h2>
<p>Each node on the blockchain network needs the ability to communicate with other nodes (peers) on the network in order to:</p>
<ul>
<li>Get an updated blockchain from its peers</li>
<li>Broadcasting to other nodes when it has an updated version of the blockchain</li>
<li>Each peer-to-peer server uses web sockets instead of HTTP to communicate with each node.</li>
</ul>
<p>Blockchain synchronization between nodes is done by sending a synchronization message to other nodes as soon as new block is mined on any node. However, before a node replaces its blockchain from an update it received from one of its peers, it needs to check that the updated chain is longer than its current chain and that the new blockchain is valid (by validating its hashes). For new nodes that just join the network, they get an updated version of the blockchain from one of its peers.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Workshop" duration="45">
        <p>In this workshop, you will write your blockchain in Google&#39;s Go Programming language. Define your own blockchain data structure, form your blockchain functionalities, create your transaction management, provide rest API and lastly blockchain data synchronisation. Let us all recap how a transaction works between two or more parties in a traditional banking transfer system vs blockchain.</p>
<h2>Today&#39;s banking system (Remittance Cycle)</h2>
<p><img src="img/4daff8cafcaa62dd.png"></p>
<p><strong>Q: What if the banking software crash? </strong></p>
<p>A: Of course definitely there is a downtime and recovery process takes place in the bank. A customer won&#39;t able to perform fund transfer during that time. All customer have to wait until the system is fully up and operational. That leads to a single point of failure in my opinion.</p>
<p><strong>Q: Looks like there is a lot of parties involved in between this wire transfer cycle?</strong></p>
<p>A: Yes the seller&#39;s bank and the buyer&#39;s bank. Sometimes we might have a clearinghouse as well. With all these dependencies in place that is the reason why bank need 1-2 working days to clear the funds abroad.</p>
<h2>Blockchain scenario (CryptoCurrency)</h2>
<p>Shows how transaction happens on the blockchain network:-</p>
<p><img src="img/2d9d1926d91629e6.png"></p>
<p>All transactions record are publicly available. Every single transfer is recorded on the distributed ledger.</p>
<p><strong>Q: Which technology has the most transparency if a side by side comparison is done?</strong></p>
<p>A: Definitely not the banking system, if there are a fraud and insider job in the bank it has to wait till an audit exercise to discover as an incident. Therefore blockchain is an evolution. An effective e-commerce platform is overdue without an evolution and well-integrated payment technology with transparency.</p>
<h2>Developing your own Blockchain</h2>
<p>Define a data structure to hold all your blockchain data</p>
<p>A Block struct with the following members</p>
<p><img src="img/45e785e87a6f31ca.png"></p>
<p>A Blockchain struct with the following members</p>
<p><img src="img/386285bb789948ad.png"></p>
<p>A Transaction struct with the following members</p>
<p><img src="img/d3d232ad1a6b1ab3.png"></p>
<h2>Requirement</h2>
<ul>
<li>Define a type where is a list of the Block structure.</li>
<li>Define a function NewBlock to instantiate new Block structure and return the structure. This function takes in three parameters.</li>
<li>Define a function NewTranaction to instantiate a new Transaction structure and return the structure. This function takes in three parameters.</li>
<li>Create a interface name it as Chain with the following implementation functions<ul>
<li>AddBlock(block *Block)</li>
<li>GetLastBlock() *Block</li>
<li>GetBlocks() Blocks</li>
<li>IsChainValid() bool<br><br></li>
</ul>
</li>
<li>Define a function NewBlockchain to instantiate new Chain Interface and return the Blockchain structure. This function takes in no parameters. In fact, in this function, we need to create a genesis block and also add the genesis block into the blockchain list.</li>
<li>Define a function that hashes every single block in the blockchain.</li>
<li>Define a function consist of blocks within a blockchain structure. Take in one parameter the Block. Pointer concept to be tested here.</li>
<li>Define a function that returns all the blocks</li>
<li>Define a function that returns the last block from the blockchain</li>
<li>Define a function that all the block in the chain is valid</li>
<li>Define 6 rest API endpoint using GIN<ul>
<li>/blocks <strong>GET</strong></li>
<li>/pay <strong>POST</strong> with payload</li>
<li>/new-wallet <strong>GET</strong> with query amount</li>
<li>/wallets <strong>GET</strong></li>
<li>/is-chain-valid <strong>GET</strong></li>
<li>/ws <strong>GET</strong> - data synchronization</li>
</ul>
</li>
<li>Define new end point new-wallet, instantiate the wallet struct<ul>
<li>Store the wallet struct to a golang map</li>
<li>Set the public key as the key</li>
<li>Add an amount property to the wallet struct</li>
<li>Initialize the amount</li>
<li>Store the wallet struct as the map value</li>
</ul>
</li>
<li>Modify the pay end point with additional logic, validate both the from and to address against the wallet map. Check the To account with sufficient balance. Validate from account cannot send value to itself.</li>
</ul>
<aside class="special"><p>Implement the blocks synchronization logic using Gorilla. Sync the blocks data across via WebSocket.</p>
</aside>
<aside class="warning"><p>Do not need to implement a complete P2P data synchronization.<br></p>
</aside>
<aside class="special"><p>Spawn off another node that connect to the server node, make a transfer on the master node and witness the blocks synchronization takes place.</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Workshop Solution" duration="300">
        <h2>Step by step development</h2>
<ol type="1">
<li>Create a file name it as &#34;blockchain.go&#34; using an IDE (Atom/Visual Studio Code)</li>
</ol>
<p><a href="https://github.com/kenken64/iss-blockchain-go" target="_blank">Github</a></p>
<h2>Full Source code</h2>
<h2>blockchain.go</h2>
<pre><code>package main

import (
    &#34;crypto/ecdsa&#34;
    &#34;crypto/elliptic&#34;
    &#34;crypto/rand&#34;
    &#34;crypto/sha256&#34;
    &#34;encoding/json&#34;
    &#34;flag&#34;
    &#34;fmt&#34;
    &#34;log&#34;
    &#34;net/http&#34;
    &#34;os&#34;
    &#34;sync&#34;
    &#34;time&#34;

    &#34;github.com/gin-gonic/gin&#34;
    &#34;github.com/gorilla/websocket&#34;
    &#34;golang.org/x/crypto/ripemd160&#34;
)

// data structure of the block
type Block struct {
    Index      int         `json:&#34;index&#34;`
    Timestamp  time.Time   `json:&#34;date&#34;`
    LastHash   string      `json:&#34;prevHash&#34;`
    Hash       string      `json:&#34;hash&#34;`
    Data       interface{} `json:&#34;transaction&#34;`
    nonce      uint32
    difficulty int
}

// list of blockchains
type Blocks []*Block

var mutex = &amp;sync.Mutex{}

// interface consist all the function of the blockchain struct
type Chain interface {
    AddBlock(block *Block)
    GetLastBlock() *Block
    GetBlocks() Blocks
    IsChainValid() bool
    ClearBlocks()
}

type BlockChain struct {
    Blocks Blocks `json:&#34;Blocks&#34;`
}

type Transaction struct {
    From   string  `json:&#34;from&#34;`
    To     string  `json:&#34;to&#34;`
    Amount float64 `json:&#34;amount&#34;`
    Date   time.Time
}

const version = byte(0x00)
const addressChecksumLen = 4

// Wallet stores private and public keys
type Wallet struct {
    PrivateKey ecdsa.PrivateKey
    PublicKey  []byte
    Balance    float64
}

func NewBlock(index int, data interface{},
    timestamp time.Time) *Block {
    return &amp;Block{
        Index:     index,
        Timestamp: timestamp,
        Data:      data,
    }
}

func NewTransaction(from string, to string, amount float64) *Transaction {
    return &amp;Transaction{
        From:   from,
        To:     to,
        Amount: amount,
        Date:   time.Now(),
    }
}

func (b *Block) createHash() string {
    d := fmt.Sprintf(&#34;%v%v%v%v&#34;, b.Index, b.LastHash, b.Timestamp, b.Data)
    h := sha256.New()
    h.Write([]byte(d))
    return fmt.Sprintf(&#34;%x&#34;, h.Sum(nil))
}

func NewBlockChain() Chain {
    date, error := time.Parse(time.RFC3339, &#34;2018-08-20T22:08:41+00:00&#34;)
    if error != nil {
        panic(error)
    }
    // create genesis block
    genesisBlock := NewBlock(0, &#34;Genesis Block&#34;, date)
    genesisBlock.LastHash = &#34;0&#34;
    genesisBlock.Hash = genesisBlock.createHash()

    var blocks Blocks
    blocks = append(blocks, genesisBlock)

    return &amp;BlockChain{
        Blocks: blocks,
    }
}

func (b *BlockChain) AddBlock(block *Block) {
    block.LastHash = b.GetLastBlock().Hash
    block.Hash = block.createHash()
    b.Blocks = append(b.Blocks, block)
}

func (b *BlockChain) GetLastBlock() *Block {
    return b.Blocks[len(b.Blocks)-1]
}

func (b *BlockChain) GetBlocks() Blocks {
    return b.Blocks
}

func (b *BlockChain) ClearBlocks() {
    emptyBlocks := make([]*Block, 0)
    fmt.Println(&#34;empty blocks [%s]&#34;, len(emptyBlocks))
    b.Blocks = emptyBlocks
}

func (b *BlockChain) IsChainValid() bool {
    for i := 1; i &lt; len(b.Blocks); i++ {
        currentBlock := b.Blocks[i]
        prevBlock := b.Blocks[i-1]

        if currentBlock.Hash != currentBlock.createHash() {
            return false
        }

        if currentBlock.LastHash != prevBlock.Hash {
            return false
        }
    }

    return true
}

// NewWallet creates and returns a Wallet
func NewWallet() *Wallet {
    private, public := newKeyPair()
    wallet := Wallet{private, public, 10000}

    return &amp;wallet
}

// GetAddress returns wallet address
func (w Wallet) GetAddress() []byte {
    pubKeyHash := HashPubKey(w.PublicKey)

    versionedPayload := append([]byte{version}, pubKeyHash...)
    checksum := checksum(versionedPayload)

    fullPayload := append(versionedPayload, checksum...)
    address := Base58Encode(fullPayload)

    return address
}

// HashPubKey hashes public key
func HashPubKey(pubKey []byte) []byte {
    publicSHA256 := sha256.Sum256(pubKey)

    RIPEMD160Hasher := ripemd160.New()
    _, err := RIPEMD160Hasher.Write(publicSHA256[:])
    if err != nil {
        log.Panic(err)
    }
    publicRIPEMD160 := RIPEMD160Hasher.Sum(nil)

    return publicRIPEMD160
}

func checksum(payload []byte) []byte {
    firstSHA := sha256.Sum256(payload)
    secondSHA := sha256.Sum256(firstSHA[:])

    return secondSHA[:addressChecksumLen]
}

func newKeyPair() (ecdsa.PrivateKey, []byte) {
    curve := elliptic.P256()
    private, err := ecdsa.GenerateKey(curve, rand.Reader)
    if err != nil {
        log.Panic(err)
    }
    pubKey := append(private.PublicKey.X.Bytes(), private.PublicKey.Y.Bytes()...)

    return *private, pubKey
}

var wsupgrader = websocket.Upgrader{
    ReadBufferSize:  1024,
    WriteBufferSize: 1024,
    CheckOrigin:     func(r *http.Request) bool { return true },
}

func wshandler(w http.ResponseWriter, r *http.Request, b Chain) {
    conn, err := wsupgrader.Upgrade(w, r, nil)
    if err != nil {
        fmt.Println(&#34;Failed to set websocket upgrade: %+v&#34;, err)
        return
    }
    //defer conn.Close()

    go func() {
        for {
            _, message, error := conn.ReadMessage()
            if error != nil {
                fmt.Println(&#34;read: &#34;, error)
                return
            }
            time.Sleep(2 * time.Second)
            fmt.Println(&#34;message:&#34;, string(message))
            for _, bb := range b.GetBlocks() {
                b, err := json.Marshal(bb)
                if err != nil {
                    fmt.Println(err)
                    return
                }
                conn.WriteJSON(string(b))
            }

        }
    }()
}

func main() {
    fmt.Println(&#34;[ Starting Blockchain API Server ]&#34;)
    // Instantiate a new blockchain
    blockchain := NewBlockChain()
    wallets := make(map[string]*Wallet)
    r := gin.Default()

    help := flag.Bool(&#34;help&#34;, false, &#34;Display Help&#34;)
    host := flag.String(&#34;h&#34;, &#34;&#34;, &#34;Host Address and Port&#34;)
    dest := flag.String(&#34;d&#34;, &#34;&#34;, &#34;Dest MultiAddr String&#34;)
    flag.Parse()
    if *help {
        fmt.Printf(&#34;This program demonstrates a simple blockchain\n\n&#34;)
        fmt.Printf(&#34;Usage: Run &#39;./blockchain -h &lt;hostname:port&gt; -d &lt;peershost:port&gt;\n&#34;)

        os.Exit(0)
    }

    blocksSize := len(blockchain.GetBlocks())
    fmt.Println(&#34;Total block size : &#34;, blocksSize)
    fmt.Println(&#34;readsssss:&#34;, *dest)
    if *dest != &#34;&#34; {
        URL := &#34;ws://&#34; + *dest + &#34;/ws&#34;

        var dialer *websocket.Dialer

        conn, _, err := dialer.Dial(URL, nil)
        //defer conn.Close()
        go func() {

            if err != nil {
                fmt.Println(err)
                return
            }
            for {
                b, err := json.Marshal(blockchain.GetBlocks())
                if err != nil {
                    fmt.Println(err)
                    return
                }

                conn.WriteJSON(b)
                //i := Block{}
                mutex.Lock()
                var jsonStr = &#34;&#34;
                err2 := conn.ReadJSON(&amp;jsonStr)

                if err2 != nil {
                    fmt.Println(&#34;read:&#34;, err2)
                    return
                }
                fmt.Println(jsonStr)
                //var fromJson map[string]interface{}
                var syncBlock Block
                if err := json.Unmarshal([]byte(jsonStr), &amp;syncBlock); err != nil {
                    panic(err)
                }
                fmt.Println(syncBlock)
                childNodeBlocks := blockchain.GetBlocks()
                foundAny := false
                for _, v := range childNodeBlocks {
                    if v.Index == syncBlock.Index {
                        // Found!
                        fmt.Println(v.Index)
                        foundAny = true
                        break
                    }
                }
                fmt.Println(foundAny)
                if foundAny == false {
                    newSyncBlock := NewBlock(len(childNodeBlocks), syncBlock.Data, time.Now())
                    blockchain.AddBlock(newSyncBlock)
                }
                mutex.Unlock()
            }
        }()
    }

    r.GET(&#34;/ws&#34;, func(c *gin.Context) {
        wshandler(c.Writer, c.Request, blockchain)
    })

    r.GET(&#34;/new-wallet&#34;, func(c *gin.Context) {
        var incomingWallet Wallet
        wallet := NewWallet()
        if c.BindQuery(&amp;incomingWallet) == nil {
            log.Println(&#34;====== Only Bind Query String ======&#34;)
            log.Println(incomingWallet.Balance)
            wallet.Balance = incomingWallet.Balance
        }
        a := wallet.GetAddress()
        wallets[string(a)] = wallet

        var jsonWallet struct {
            PublicKey string  `json:&#34;publicKey&#34;`
            Amount    float64 `json:&#34;Amount&#34;`
        }

        jsonWallet.PublicKey = string(a)
        jsonWallet.Amount = wallet.Balance

        c.JSON(http.StatusOK, gin.H{&#34;wallets&#34;: jsonWallet})
    })

    r.GET(&#34;/wallets&#34;, func(c *gin.Context) {
        c.JSON(http.StatusOK, gin.H{&#34;wallets&#34;: wallets})
    })

    r.GET(&#34;/blocks&#34;, func(c *gin.Context) {
        currentBlocks := blockchain.GetBlocks()
        var interfaceSlice []interface{} = make([]interface{}, len(currentBlocks))
        for i := range currentBlocks {
            blockJson := &amp;Block{
                Index:     currentBlocks[i].Index,
                Timestamp: currentBlocks[i].Timestamp,
                LastHash:  currentBlocks[i].LastHash,
                Hash:      currentBlocks[i].Hash,
                Data:      currentBlocks[i].Data,
            }
            interfaceSlice[i] = blockJson
        }

        c.JSON(http.StatusOK, gin.H{&#34;blocks&#34;: interfaceSlice})
    })

    r.POST(&#34;/pay&#34;, func(c *gin.Context) {
        var err error
        var incomingTransaction Transaction
        if err = c.BindJSON(&amp;incomingTransaction); err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{
                &#34;error&#34;:  &#34;json decoding : &#34; + err.Error(),
                &#34;status&#34;: http.StatusInternalServerError,
            })
            return
        }

        fromA := incomingTransaction.From
        toA := incomingTransaction.To
        if fromA != toA {
            fromW, present := wallets[fromA]
            if present {
                toW, present := wallets[toA]
                if present {
                    if fromW.Balance &gt;= incomingTransaction.Amount {
                        fromW.Balance = fromW.Balance - incomingTransaction.Amount
                        toW.Balance = toW.Balance + incomingTransaction.Amount

                        lengthOfChain := len(blockchain.GetBlocks())
                        xferTransaction := NewTransaction(fromA, toA, incomingTransaction.Amount)
                        transferBlock := NewBlock(lengthOfChain, xferTransaction, time.Now())
                        blockchain.AddBlock(transferBlock)
                        c.JSON(http.StatusOK, gin.H{&#34;transferValidity&#34;: blockchain.IsChainValid()})
                        return
                    }
                }
            }
        }

        c.JSON(http.StatusInternalServerError, gin.H{&#34;error&#34;: &#34;invalid&#34;})
    })

    r.GET(&#34;/is-chain-valid&#34;, func(c *gin.Context) {
        c.JSON(http.StatusOK, gin.H{&#34;chain-validity&#34;: blockchain.IsChainValid()})
    })

    fmt.Println(&#34;Hostname and Port &#34;, dest)
    var finalPortAssignment = &#34;localhost:3005&#34;
    if *host != &#34;&#34; {
        finalPortAssignment = *host
        fmt.Println(&#34;default Hostname and Port &#34;, finalPortAssignment)
    }

    r.Run(finalPortAssignment)
}

</code></pre>
<h2>base58.go</h2>
<pre><code>package main

import (
    &#34;bytes&#34;
    &#34;math/big&#34;
)

var b58Alphabet = []byte(&#34;123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz&#34;)

// Base58Encode encodes a byte array to Base58
func Base58Encode(input []byte) []byte {
    var result []byte

    x := big.NewInt(0).SetBytes(input)

    base := big.NewInt(int64(len(b58Alphabet)))
    zero := big.NewInt(0)
    mod := &amp;big.Int{}

    for x.Cmp(zero) != 0 {
        x.DivMod(x, base, mod)
        result = append(result, b58Alphabet[mod.Int64()])
    }

    // https://en.bitcoin.it/wiki/Base58Check_encoding#Version_bytes
    if input[0] == 0x00 {
        result = append(result, b58Alphabet[0])
    }

    ReverseBytes(result)

    return result
}

// Base58Decode decodes Base58-encoded data
func Base58Decode(input []byte) []byte {
    result := big.NewInt(0)

    for _, b := range input {
        charIndex := bytes.IndexByte(b58Alphabet, b)
        result.Mul(result, big.NewInt(58))
        result.Add(result, big.NewInt(int64(charIndex)))
    }

    decoded := result.Bytes()

    if input[0] == b58Alphabet[0] {
        decoded = append([]byte{0x00}, decoded...)
    }

    return decoded
}
</code></pre>
<h2>utils.go</h2>
<pre><code>package main

// ReverseBytes reverses a byte array
func ReverseBytes(data []byte) {
    for i, j := 0, len(data)-1; i &lt; j; i, j = i+1, j-1 {
        data[i], data[j] = data[j], data[i]
    }
}
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Workshop Bonus" duration="60">
        <h2>Setup Flutter</h2>
<p>Please follow the setup on the following <a href="https://flutter.io/get-started/install/" target="_blank">website</a></p>
<ul>
<li>Git clone the flutter wallet app from the following <a href="https://github.com/kenken64/iss-blockchain-wallet" target="_blank">Github</a> repository.</li>
<li>Implement the transfer functionality using http <strong>POST</strong> calling the blockchain master node&#39;s rest API /pay.</li>
<li>List all the blocks calling the http <strong>GET</strong> /blocks on the history tab of the wallet app.</li>
<li>Run wallet app</li>
</ul>
<pre><code>flutter run
</code></pre>


      </google-codelab-step>
    
  </google-codelab>

  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-49880327-14', 'auto');

    (function() {
      var gaCodelab = '0';
      if (gaCodelab) {
        ga('create', gaCodelab, 'auto', {name: 'codelab'});
      }

      var gaView;
      var parts = location.search.substring(1).split('&');
      for (var i = 0; i < parts.length; i++) {
        var param = parts[i].split('=');
        if (param[0] === 'viewga') {
          gaView = param[1];
          break;
        }
      }
      if (gaView && gaView !== gaCodelab) {
        ga('create', gaView, 'auto', {name: 'view'});
      }
    })();
  </script>

</body>
</html>
